import{_ as s,D as o,c as l,m as i,a,I as t,U as n,o as r}from"./chunks/framework.BVbjJPPA.js";const Q=JSON.parse('{"title":"Questions Collections","titleTemplate":"SQL","description":"Questions Collections","frontmatter":{"title":"Questions Collections","titleTemplate":"SQL","description":"Questions Collections","head":[["meta",{"name":"description","content":"Questions Collections"}]],"tags":["SQL"],"categories":["Notes"]},"headers":[],"relativePath":"notes/sql/Questions-Collections.md","filePath":"notes/sql/Questions-Collections.md","lastUpdated":1705063846000}'),d={name:"notes/sql/Questions-Collections.md"},c={id:"questions-collections",tabindex:"-1"},u=i("a",{class:"header-anchor",href:"#questions-collections","aria-label":'Permalink to "Questions Collections <Badge type="tip" text="SQL" /><Badge type="warning" text="Notes" />"'},"​",-1),p=n('<h2 id="what-is-nosql" tabindex="-1">What is NoSQL? <a class="header-anchor" href="#what-is-nosql" aria-label="Permalink to &quot;What is NoSQL?&quot;">​</a></h2><p><code>NoSQL</code>, short for &quot;Not Only SQL&quot; or &quot;non-relational&quot;, is a category of database management systems that differ from traditional relational databases in their approach to data storage and retrieval. Here&#39;s a rundown of its key characteristics:</p><p><strong>Data Storage:</strong></p><ul><li><em>No rigid schema</em>: Unlike relational databases with predefined tables and columns, NoSQL databases offer flexible data structures like documents, key-value pairs, or graphs. Data can evolve organically without schema modifications.</li><li><em>Scalability</em>: NoSQL databases excel at horizontal scaling, where additional servers are added to handle increasing data volume and user requests.</li><li><em>Distributed architecture</em>: Data is distributed across multiple servers, promoting fault tolerance and improving performance.</li></ul><p><strong>Data Retrieval:</strong></p><ul><li><em>Non-SQL query language</em>: Each NoSQL type employs its own query language, distinct from SQL use in relational databases. Some languages are more expressive than others, focusing on specific data models.</li><li><em>Flexible querying</em>: NoSQL databases prioritize adaptability and allow querying based on various data attributes and structures.</li></ul><p><strong>Use Cases:</strong></p><ul><li><em>Big data</em>: NoSQL databases are ideal for storing and processing massive datasets efficiently, making them popular for analysis, real-time applications, and large- scale web services.</li><li><em>Unstructured</em> data: NoSQL databases handle unstructured and semi-structured data efficiently, such as social media posts, senor readings, and log files.</li><li><em>High availability</em>: Distributed and fault-tolerant architecture ensures uninterrupted data access even if individual servers fail.</li></ul><p><strong>Popular NoSQL Types:</strong></p><ul><li>Document databases (MongoDB, Couchbase)</li><li>Key-value stores (Redis, Cassandra)</li><li>Wide-column stores (Amazon DynamoDB, HBase)</li><li>Graph databases (Neo4j, OrientDB)</li></ul><p><strong>Pros and Cons:</strong></p><p>Pros:</p><ul><li>Scalability and flexibility</li><li>Efficiently and unstructured data</li><li>High availability and fault tolerance</li><li>Simpler schema design and data modification</li></ul><p>Cons:</p><ul><li>No standardized query language</li><li>Potential for data consistency issues in some types</li><li>May require additional expertise for query optimization and data management</li></ul><h2 id="state-the-difference-between-where-and-having-in-sql" tabindex="-1">State the difference between WHERE and HAVING in SQL? <a class="header-anchor" href="#state-the-difference-between-where-and-having-in-sql" aria-label="Permalink to &quot;State the difference between WHERE and HAVING in SQL?&quot;">​</a></h2><p>WHERE:</p><ul><li>Filters individual rows before grouping and aggregation.</li><li>Operates on individual rows within tables.</li><li>Typically used with SELECT, UPDATE, and DELETE statements.</li></ul><p>HAVING:</p><ul><li>Filters groups of rows after aggregation.</li><li>Operates on the results of aggregate functions (like SUM, COUNT, AVG)</li><li>Used exclusively with the GROUP BY clause.</li></ul><p>Key Difference:</p><ul><li>Timing: WHERE files before grouping, HAVING filters after grouping.</li><li>Scope: WHERE works in individual rows, HAVING works on aggregated results.</li><li>Usage: WHERE can be sued with various statements, HAVING only with GROUP BY.</li></ul><p>When to Use Each:</p><ul><li>Use WHERE to filter rows based on specific conditions before aggregation.</li><li>Use HAVING to filter groups of rows based on aggregate values after aggregation.</li></ul>',24);function g(m,f,h,b,y,S){const e=o("Badge");return r(),l("div",null,[i("h1",c,[a("Questions Collections "),t(e,{type:"tip",text:"SQL"}),t(e,{type:"warning",text:"Notes"}),a(),u]),p])}const _=s(d,[["render",g]]);export{Q as __pageData,_ as default};
